This repository is a collection of the polynomial and matrix math projects I have developed alongside a basic text-based terminal user interface to showcase the programs. All files are used in the demonstration except for Main.java, which is where I was testing the accuracy of the eigenvalue program. This ReadMe will be split into 3 brief parts: a description of the user interface, a description of the polynomial root solver, and a description of the matrix program.
First, the user interface. It begins by prompting you to choose between a polynomial, matrix, or exit option. The polynomial choice brings you to a menu where you can select one of multiple preset polynomials or create your own by inputting an invalid choice. Once on is chosen, it prompts you to choose between a set of operations like deriving, calculating, and root-solving. After your response, it performs the operation (or not if your response is not a valid choice). If you chose the matrices instead, you are prompted with a similar menu, but an invalid choice will instead generate a random matrix of a size of your choice instead.
Second, the polynomial root solver. The polynomial program stores polynomials as an array of complex degrees whose indices correspond to the degree of the term to which they are attached. Under this scheme, deriving and calculating is basic to implement, with the focus of the program being the root solving. This program uses the Aberth Method, an extension of Newton's Method in which a set of complex "points" can be visualized as attracting towards roots and repelling from one another. Such a method draws points towards roots while repelling them away from each such that each point gravitates towards a different root.
Third, the matrix program. The matrix program stores matrices as an array of arrays of complex numbers that represent the entries of the matrix. Operations included in the Matrix class include upper triangular row reduction, Householder QR decompositions, upper Hessenberg similarity transformations, determinant calculations, rref operations, inverse calculations, and basic arithmetic in the form of multiplication, addition, and subtraction of matrices. The focus of the matrix program is on finding eigenvalues, much like the focus for the polynomial solver was on finding roots. The program does this by first using similarity transforms to bring a given square matrix to its upper Hessenberg form, through a series of Householder reductions, that has the same eigenvalues so as to reduce computational complexity. Then, it follows with a QR algorithm with explicit shifts. This algorithm uses a series of Givens rotations with an explicit shift along the diagonal to zero out the (n,n) coordinate, than right multiplies so that the iteration acts as a similarity transformation that will converge because of its likeness to the power method of finding eigenvalues. Once a subdiagonal zero has been found, the algorithm recursively splits the deflated upper Hessenberg form matrix into a left and right matrix and finds their eigenvalues using the same method.
